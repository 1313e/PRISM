# -*- coding: utf-8 -*-

"""
ImagineLink
===========
Provides the definition of the :class:`~ImagineLink` class.

Available classes
-----------------
:class:`~ImagineLink`
    :class:`~ModelLink` class wrapper for any model in the IMAGINE pipeline,
    used for testing the functonality of the PRISM pipeline.

"""


# %% IMPORTS
from __future__ import (absolute_import, division, print_function,
                        with_statement)

# Built-in imports
from codecs import open
import logging

# PRISM imports
from prism import ModelLink

# Hammurapy imports
from imagine.base_classes import observables_generator
from imagine import hammurapy
from imagine.hammurapy.hammurapy import Hammurapy
import numpy as np

# All declaration
__all__ = ['ImagineLink']

logger = logging.getLogger('IMAGINE')


# %% CLASS DEFINITION
class ImagineLink(ModelLink):
    """
    :class:`~ModelLink` class wrapper for any model in the IMAGINE pipeline,
    used for testing the functonality of the PRISM pipeline.

    Formatting data_idx
    -------------------
    obs_type : str
        The specific observable type of which the data value needs to be taken,
        using the names as defined by the :class:`~Hammurapy` class.
    obs_subtype : str
        The observable subtype (e.g., Stokes I, Q or U for synchrotron) for the
        data value, using the names as defined by the :class:`~Hammurapy`
        class.
    pixel_idx : int
        The index of the pixel at which the data value needs to be taken, as
        generated by the HEALPix map.

    """

    def __init__(self, hammu_model, *args, **kwargs):
        # Initialize Hammurapy_model object
        self._hammu = Hammurapy_model(
            hammu_model, 350, 350,
            hammurabi_path='hammurabi_3',
            conf_directory='%s/confs' % (hammurapy.__path__[0]))

        # Setting loaded ModelLink name to include hammu_model
        self.name = 'ImagineLink_%s' % (hammu_model)

        # Request only single model calls
        self.call_type = 'single'

        # Request controller calls
        self.MPI_call = False

        # Inheriting ModelLink __init__()
        super(ImagineLink, self).__init__(*args, **kwargs)

    @property
    def _default_model_parameters(self):
        par_dict = self._hammu.model_parameter_dict

        return(par_dict)

    def call_model(self, emul_i, model_parameters, data_idx):
        logger.info("Starting to observe parameters")

        # Create a temp working directory
        temp_folder = self._hammu._make_temp_folder()
        logger.info('Using %s', temp_folder)

        # Create the parameter file in the temporary directory
        self._hammu._make_parameter_file(temp_folder, model_parameters)
        logger.info('Stored parameter file')

        # Call Hammurabi
        logger.info('Calling Hammurabi')
        self._hammu._call_hammurabi(temp_folder)
        logger.info('Hammurabi finished')

        # Read in the rotation measure map and build an observable out of it
        observables = self._hammu._build_observables(temp_folder)

        # Delete the temporary folder
        self._hammu._remove_folder(temp_folder)

        # Select the correct data points according to data_idx
        obs_data = []
        for idx in data_idx:
            obs_data.append(observables[idx[0]][idx[1]][idx[2]])

            # Make sure that RM values are never higher than 100
            if(idx[0] == 'rm_observable'):
                if(obs_data[-1] < -100):
                    obs_data[-1] = -100
                elif(obs_data[-1] > 100):
                    obs_data[-1] = 100

        # Save the Hammurabi parameters to a .txt-file
        if(emul_i == 0):
            with open('last_call_log.txt', 'w') as f:
                f.write(self._hammu.last_call_log)

        # Return it
        return(obs_data)

    def get_md_var(self, emul_i, data_idx):
        super(ImagineLink, self).get_md_var(emul_i=emul_i, data_idx=data_idx)


class Hammurapy_model(observables_generator, Hammurapy):
    def __init__(self, hammu_model, box_dimensions, resolution, *args,
                 **kwargs):

        self.hammu_model = hammu_model.lower()
        self.box_dimensions = np.empty(3)
        self.box_dimensions[:] = box_dimensions

        self.resolution = np.empty(3)
        self.resolution[:] = resolution

        super(Hammurapy_model, self).__init__(*args, **kwargs)

        # JF12 Model
        if(self.hammu_model == 'jf12'):
            n = 3
            self.model_parameter_dict = {
                    'b51_ran_b1': self._interval(10.8, 2.33, n),
                    'b51_ran_b2': self._interval(6.96, 1.58, n),
                    'b51_ran_b3': self._interval(9.59, 1.10, n),
                    'b51_ran_b4': self._interval(6.96, 0.87, n),
                    'b51_ran_b5': self._interval(1.96, 1.32, n),
                    'b51_ran_b6': self._interval(16.34, 2.53, n),
                    'b51_ran_b7': self._interval(37.29, 2.39, n),
                    'b51_ran_b8': self._interval(10.35, 4.43, n),
                    'b51_coh_b1': self._interval(0.1, 1.8, n),
                    'b51_coh_b2': self._interval(3.0, 0.6, n),
                    'b51_coh_b3': self._interval(-0.9, 0.8, n),
                    'b51_coh_b4': self._interval(-0.8, 0.3, n),
                    'b51_coh_b5': self._interval(-2.0, 0.1, n),
                    'b51_coh_b6': self._interval(-4.2, 0.5, n),
                    'b51_coh_b7': self._interval(0.0, 1.8, n),
                    'b51_z0_spiral': self._positive_interval(0.61, 0.04, n),
                    'b51_z0_smooth': self._positive_interval(2.84, 1.30, n),
                    'b51_r0_smooth': self._positive_interval(10.97, 3.80, n),
                    'b51_b0_smooth': self._interval(4.68, 1.39, n),
                    'b51_b0_x': self._interval(4.6, 0.3, n),
                    'b51_Xtheta': self._positive_interval(49., 1., n),
                    'b51_r0_x': self._positive_interval(2.9, 0.1, n),
                    'b51_h_disk': self._positive_interval(0.4, 0.03, n),
                    'b51_Bn': self._interval(1.4, 0.1, n),
                    'b51_Bs': self._interval(-1.1, 0.1, n),
                    'b51_z0_halo': self._positive_interval(5.3, 1.6, n),
                    'b51_b_ring': self._interval(0.1, 0.1, n),
                    'b51_b0_interior': self._interval(7.63, 1.39, n),
                    'b51_reg_b0': [0, 10, 1],
                    'b51_shift': [0, 10, 1]}

        # Constant Magnetic Field Model
        elif(self.hammu_model == 'cmf'):
            self.model_parameter_dict = {
                    'B_field_b0': [0, 10, 6],
                    'B_x_const': [-1, 1, 0.7],
                    'B_y_const': [-1, 1, 0.7],
                    'B_z_const': [-1, 1, 0]}

    def _interval(self, mean, sigma, n):
        return([mean-n*sigma, mean+n*sigma, mean])

    def _positive_interval(self, mean, sigma, n):
        return([max(0, mean-n*sigma), mean+n*sigma, mean])

    def get_default_parameters_dict(self):
        result_dict = super(Hammurapy_model,
                            self).get_default_parameters_dict()
        if(self.hammu_model == 'jf12'):
            result_dict['B_field_type'] = '7'
        elif(self.hammu_model == 'cmf'):
            result_dict['B_field_type'] = '11'
        result_dict['obs_shell_index_numb'] = '1'
        result_dict['total_shell_numb'] = '1'
        result_dict['obs_NSIDE'] = '16'
        result_dict['TE_interp'] = 'T'
        result_dict['B_field_do_random'] = 'F'
        result_dict['do_rm'] = 'T'
        result_dict['do_sync_emission'] = 'T'
        result_dict['do_dm'] = 'F'
        result_dict['do_dust'] = 'F'
        result_dict['do_tau'] = 'F'
        result_dict['do_ff'] = 'F'
        result_dict['B_field_interp'] = 'T'
        result_dict['use_B_analytic'] = 'F'
        return(result_dict)

    def _make_parameter_file(self, working_directory, model_parameter_dict):
        super(Hammurapy_model, self)._make_parameter_file(
                working_directory,
                self.resolution,
                self.box_dimensions,
                custom_parameters=model_parameter_dict)
